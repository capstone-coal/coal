## to generate preprocessed hyperpixels for input into a neural network,
## define global parameters specifying format,
## read metadata from image headers,
## get each hyperpixel from the image,
## preprocess it as necessary,
## and normalize it into a consistent format.

# define global constants
minimumWavelength = 346 # nanometers
maximumWavelength = 2506 # nanometers
numberOfBuckets = 128
bucketSize = (maximumWavelength - minimumWavelength) / numberOfBuckets

# read dimensions from header
B = readBandsFromHeader(file.hdr)
X = readColumnsFromHeader(file.hdr)

# read list of wavelengths from header
wavelengthList = readWavelengthListFromHeader(file.hdr)

# buffer of size B*X*sizeof(float32)
# represented as 2-dimensional array for convenience
float32 buffer[B][X]

# pixel counter
x = 1

# get the next hyperpixel from the BIL image
function coal.format.aviris.getHyperpixel(file)

    # read line of data into buffer
    if (x == 1)
        for (i in [1..B])
            for (j in [1..X])
                read(file, buffer[i][j], sizeof(float32))

    # allocate an array of B floats to store the hyperpixel
    hyperpixel = new float32[B]

    # copy the elements into the hyperpixel
    for (i in [1..B])
        hyperpixel[i] = buffer[i][x]

    # increment x and roll over at end of line
    if (x < X)
        ++x
    else
        x = 1

    # return hyperpixel
    return hyperpixel

# return a preprocessed copy of a hyperpixel
# to account for vapor, scaling, etc., as necessary
function coal.format.aviris.preprocess(hyperpixel)

    # allocate an array of B floats to store the hyperpixel
    preprocessedHyperpixel = new float32[B]

    # for each band
    for (i in [1..B])

        # look up and calculate correction factors from image metadata
        correctionFactor = lookupCorrectionFactor()

        # and store the corrected value
        preprocessedHyperpixel[i] = hyperpixel[i] * correctionFactor

    # return the preprocessed hyperpixel
    return preprocessedHyperpixel

# normalize a hyperpixel for input to NN
# where the input hyperpixel is an array of B float32's in sequential order
# corresponding to each wavelength in the list read from the image header
# and the output is an array of numberOfBuckets int16's
# as dictated by the USGS digital spectral library
# by choosing and converting the first value that falls within each bucket
function coal.format.aviris.normalize(hyperpixel)

    # define wavelength and bucket index variables
    wavelengthIndex = 1
    bucketIndex = 1

    # define the offset from which the current bucket starts
    bucketOffset = minimumWavelength

    # allocate an array to store the normalized hyperpixel
    normalizedHyperpixel = new int16[numberOfBuckets]

    # for each bucket
    while (bucketIndex <= numberOfBuckets)

        # find the index of the first wavelength that falls within it
        while (wavelengthList[wavelengthIndex] < bucketOffset)
            ++wavelengthIndex

        # convert the float32 value to an int16
        # taking units into account
        # and store it in the output pixel
        normalizedHyperpixel[bucketIndex] = (int16)(hyperpixel[wavelengthIndex] * unitConversion)

        # increment the bucket index and offset
        ++bucketIndex
        bucketOffset += bucketSize

    # return the normalized hyperpixel
    return normalizedHyperpixel

## to train a neural network,
## take as input a set of hyperpixels, manual classifications for each, and desired accuracy,
## use some neural network library with preset or customizable cost functions, weight functions, etc.,
## and produce as output a trained neural network for use as a black box function.

# enumerate minerals
enum mineral_x, mineral_y, mineral_z

# define trainer using some library
# using as training data a set of (hyperpixel,classification) pairs
# with parameters for accuracy, etc.
function coal.mineral.train(trainingData, accuracy)
    trainedNetwork = some.neural.net.library.trainer(trainingData, accuracy, otherParameters)
    return trainedNetwork

## to classify each hyperpixel in an input image,
## read and decode each hyperpixel from the input image,
## use a trained neural network to classify each hyperpixel as a particular mineral,
## and write each mineral classified pixel to an output image.

# define procedure that maps a mineral classifer over an input image onto an output image
function coal.mineral.processImage(inputImage, classifier, outputImage)

    # while there is more data
    while (inputImage != EOF)

        # get the next hyperpixel from the image
        hyperpixel = coal.format.aviris.getHyperpixel(inputImage)

        # preprocess and normalize it
        preprocessedHyperpixel = coal.format.aviris.preprocess(hyperpixel)
        normalizedPreprocessedHyperpixel = coal.format.aviris.normalize(preprocessedHyperpixel)

        # classify it using the trained network
        classifiedPixel = some.neural.net.library.classify(normalizedPreprocessedHyperpixel, classifier)

        # and write it to an output file in some format
        write(classifiedPixel, outputImage)

## to classify a set of images,
## generate training data,
## train the network,
## and use it to classify each image.

# generate from USGS digital spectral library
# a training data structure representing a set of hyperpixels and classifications
classifiedHyperpixels = [(pixel_0, mineral_x), (pixel_1, mineral_y), ..., (pixel_n, mineral_z)]

# define some value for accuracy
desiredAccuracy = 0.99

# generate a neural network trained to classify minerals
mineralClassifier = coal.mineral.train(classifiedHyperpixels, desiredAccuracy)

# conceptual entry point
function main()

    # for each image in a set of images
    for (imageFilename in imageFilenames)

        # turn the image into a mineral classified image
        coal.mineral.processImage(imageFilename, mineralClassifier, imageFilename + "_mineral_classified")

